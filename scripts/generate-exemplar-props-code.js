// # generate-exemplar-props-code.js
import fs from 'node:fs';
import yaml from 'yaml';

const props = yaml.parse(fs.readFileSync(
	new URL('../src/core/data/new-properties.yaml', import.meta.url),
).toString());

let code = `// This file is automatically generated from new-properties.yaml. Don't touch 
// manually!
import { inspect } from 'sc4/utils';
const Bool = Boolean;
const Uint32 = Uint32Array;
const Uint8 = Uint8Array;
const Sint32 = Int32Array;
const Sint64 = BigInt64Array;
const Float32 = Float32Array;

function inspector(this: any) {
	let keys = Object.keys(this);
	if (keys.length === 0) {
		return inspect.hex(this[kPropertyId]);
	} else {
		return Object.fromEntries(
			Object.entries(this).map(
				([key, value]) => [key, inspect.hex(value as number, 2)]
			),
		);
	}
};

const kInspect = Symbol.for('nodejs.util.inspect.custom');
const kToPrimitive = Symbol.toPrimitive;
export const kPropertyId = Symbol.for('sc4.ExemplarPropertyId');
export const kPropertyType = Symbol.for('sc4.ExemplarPropertyType');

export default {
`;
for (let key of Object.keys(props)) {
	let obj = props[key];
	if (key.match(/^\d/)) key = `'${key}'`;
	let value = hex(obj.id);
	if (obj.options || obj.type !== 'Uint32' || Math.abs(obj.count) > 1) {
		let { type, count } = obj;
		if (Math.abs(count) > 1) {
			type = `[${type}]`;
		}
		let id = value;
		value = `{\n`;
		value += `\t\t[kToPrimitive]: () => ${id},\n`;
		value += `\t\t[kPropertyId]: ${id},\n`;
		value += `\t\t[kPropertyType]: ${type},\n`;
		value += `\t\t[kInspect]: inspector,\n`;
		for (let [key, option] of Object.entries(obj.options || [])) {
			value += `\t\t${key}: ${hex(option)},\n`;
		}
		value += '\t}';
	}
	if (obj.description) {
		code += `\t/**\n`;
		code += `${wrap(obj.description)}\n`;
		code += `\t */\n`;
	}
	code += `\t${key}: ${value},\n`;
}
code += `} as const;
`;

function hex(nr) {
	return '0x'+nr.toString(16).padStart(8, '0');
}

fs.writeFileSync(
	new URL('../src/core/data/exemplar-properties.ts', import.meta.url),
	code,
);

function wrap(description, prefix = '\t') {
	let lines = [''];
	let split = description.split(' ');
	while (split.length > 0) {
		let word = split.shift();
		if (lines.at(-1).length + word.length > 80-7) {
			lines.push(word);
		} else {
			lines[lines.length-1] += ` ${word}`;
		}
	}
	return lines.map(x => `${prefix} * ${x.trim()}`).join('\n');
}
