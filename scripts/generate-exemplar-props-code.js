// # generate-exemplar-props-code.js
import fs from 'node:fs';
import yaml from 'yaml';

const props = yaml.parse(fs.readFileSync(
	new URL('../src/core/data/new-properties.yaml', import.meta.url),
).toString());

let code = `// This file is automatically generated from new-properties.yaml. Don't touch 
// manually!
import { inspect } from 'sc4/utils';
import type { uint8, uint32, sint32, sint64, float } from 'sc4/types';
const Uint32 = Uint32Array;
const Uint8 = Uint8Array;
const Sint32 = Int32Array;
const Sint64 = BigInt64Array;
const Float = Float32Array;

function inspector(this: any) {
	let keys = Object.keys(this);
	if (keys.length === 0) {
		return inspect.hex(this[kPropertyId]);
	} else {
		return Object.fromEntries(
			Object.entries(this).map(
				([key, value]) => [key, inspect.hex(value as number, 2)]
			),
		);
	}
};

const kInspect = Symbol.for('nodejs.util.inspect.custom');
const kToPrimitive = Symbol.toPrimitive;
export const kPropertyId = Symbol.for('sc4.ExemplarPropertyId');
export const kPropertyType = Symbol.for('sc4.ExemplarPropertyType');

export const ExemplarProperty = {
`;
for (let prop of props) {
	let { name } = prop;
	if (name.match(/^\d/)) name = `'${name}'`;
	let value = hex(prop.id);
	if (prop.options || prop.type !== 'Uint32' || Math.abs(prop.count) > 1) {
		let { type, count } = prop;
		if (Math.abs(count) > 1) {
			type = `[${type}]`;
		}
		let id = value;
		value = `{\n`;
		value += `\t\t[kToPrimitive]: () => ${id},\n`;
		value += `\t\t[kPropertyId]: ${id},\n`;
		value += `\t\t[kPropertyType]: ${type},\n`;
		value += `\t\t[kInspect]: inspector,\n`;
		for (let [key, option] of Object.entries(prop.options || [])) {
			value += `\t\t${key}: ${hex(option)},\n`;
		}
		value += '\t}';
	}
	if (prop.description) {
		code += `\t/**\n`;
		code += `${wrap(prop.description)}\n`;
		code += `\t */\n`;
	}
	code += `\t${name}: ${value},\n`;
}
code += `} as const;
export default ExemplarProperty;

// IMPORTANT! We want to generate as much static type information as possible 
// because TypeScript is noticeably slower due to the massive amount of types it 
// has to recalculate all the time. That's why we dump as much information as 
// possible about the types!
`;

// Group all exemplar ids by type identifier.
let grouped = Object.groupBy(props, prop => {
	let { type, count } = prop;
	if (Math.abs(+count) > 1) {
		return `${type.toLowerCase()}[]`;
	} else {
		return type.toLowerCase();
	}
});
let sorted = {};
for (let [type, group] of Object.entries(grouped)) {
	sorted[type] = group.map(prop => [prop.name, prop.id]).flat();
}
for (let array of Object.values(sorted)) {
	array.sort((a, b) => {
		let ta = typeof a;
		let tb = typeof b;
		if (ta !== tb) {
			return ta === 'number' ? -1 : 1;
		} else {
			return ta < tb ? -1 : 1;
		}
	});
}

// Explicitly include all known string keys per type so that we can re-use them 
// later on. Makes the files a bit smaller because we don't include all the 
// strings twice.
let stringKeyMap = new Map();
for (let [type, literals] of Object.entries(sorted)) {
	let strings = literals
		.filter(value => typeof value === 'string')
		.map(name => `\t| '${name}'`)
		.join('\n');
	if (strings.length === 0) continue;
	let typeName = `StringKeys_${String(stringKeyMap.size).padStart(2, '0')}`;
	stringKeyMap.set(type, typeName);
	code += `type ${typeName} =\n${strings};\n\n`;
}

code += `export type ExemplarPropertyIdLikeToValueType<T, R = unknown> =\n`;
for (let [type, literals] of Object.entries(sorted)) {
	let union = literals
		.filter(value => typeof value === 'number')
		.map(value => '0x'+value.toString(16).padStart(8, '0'))
		.map(x => `\t\t| ${x}`)
		.join('\n');
	code += `\tT extends\n`;
	code += `${union}\n`;
	let name = stringKeyMap.get(type);
	if (name) {
		code += `\t\t| ${name}\n`;
	}
	code += `\t\t? ${type} :\n`;
}
code += `\tR;\n\n`;

// At last we'll glue all string keys together as well.
code += `export type StringKey =\n`;
let union = [...stringKeyMap.values()].map(x => `\t| ${x}`).join('\n');
code += `${union};\n`;

function hex(nr) {
	return '0x'+nr.toString(16).padStart(8, '0');
}

fs.writeFileSync(
	new URL('../src/core/exemplar-properties.ts', import.meta.url),
	code,
);

function wrap(description, prefix = '\t') {
	let lines = [''];
	let split = description.split(' ');
	while (split.length > 0) {
		let word = split.shift();
		if (lines.at(-1).length + word.length > 80-7) {
			lines.push(word);
		} else {
			lines[lines.length-1] += ` ${word}`;
		}
	}
	return lines.map(x => `${prefix} * ${x.trim()}`).join('\n');
}
